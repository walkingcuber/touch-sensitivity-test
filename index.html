<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>魔方計時器 (API 紀錄版)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Noto Sans TC', sans-serif; touch-action: manipulation; -webkit-user-select: none; user-select: none; transition: background-color 0.3s, color 0.3s; overflow: hidden; }
        .theme-black { background-color: #111827; color: #f9fafb; }
        .theme-white { background-color: #f3f4f6; color: #1f2937; }
        .theme-blue { background-color: #1e3a8a; color: #eff6ff; }
        .theme-mint { background-color: #f0fdfa; color: #0f766e; }
        .theme-synthwave { background-color: #2a1b3d; color: #f72585; }
        .theme-solarized { background-color: #fdf6e3; color: #657b83; }
        .timer-ready { color: #10b981 !important; }
        .timer-inspecting { color: #f59e0b !important; }
        .modal-content { scrollbar-width: thin; scrollbar-color: #9ca3af #4b5563; }
        .modal-content::-webkit-scrollbar { width: 8px; }
        .modal-content::-webkit-scrollbar-track { background: #4b5563; }
        .modal-content::-webkit-scrollbar-thumb { background-color: #9ca3af; border-radius: 4px; border: 2px solid #4b5563; }
        .history-item-grid { grid-template-columns: 40px 1fr 60px; }
        @media (max-width: 640px) { .history-item-grid { grid-template-columns: 30px 1fr 50px; } }
    </style>
    
    <!-- 
      *** 新增：Firebase SDK ***
      我們需要匯入 Firebase 的 App, Auth (驗證), 和 Firestore (資料庫) 功能
    -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import {
            getAuth,
            signInAnonymously,
            signInWithCustomToken,
            onAuthStateChanged
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import {
            getFirestore,
            doc,
            addDoc,
            setDoc,
            updateDoc,
            deleteDoc,
            onSnapshot,
            collection,
            query,
            writeBatch,
            getDocs,
            setLogLevel
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- 全域變數 ---
        let db, auth, userId;
        let isAuthReady = false;
        let solvesCollectionRef; // 指向 Firestore 中儲存成績的 "collection"
        let times = [];
        let state = 'initial'; // initial, inspecting, ready, timing
        let timerStartTime, timerEndTime, inspectionStartTime;
        let timerInterval, inspectionInterval;
        let pressTimeout;
        let confirmCallback = null;
        let settings = {};

        // --- DOM 元素 (與原版相同) ---
        const allDOMElements = {};

        // --- Firebase 初始化與驗證 ---
        async function initFirebase() {
            try {
                // 讀取 Canvas 環境提供的 Firebase 設定
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const firebaseConfig = JSON.parse(__firebase_config);
                
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // setLogLevel('Debug'); // 開啟此行以便在 console 中查看 Firebase 詳細日誌

                // 監聽驗證狀態變化
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        // 使用者已登入
                        userId = user.uid;
                        isAuthReady = true;

                        // 設定 Firestore 資料庫的路徑
                        // 每個使用者的成績將儲存在他們自己的私有資料夾中
                        const collectionPath = `artifacts/${appId}/users/${userId}/solves`;
                        solvesCollectionRef = collection(db, collectionPath);
                        
                        console.log("Firebase 已準備就緒，使用者 ID:", userId);
                        
                        // 驗證成功後，開始讀取雲端資料
                        loadTimesFromFirestore();
                    }
                });

                // 執行登入
                if (typeof __initial_auth_token !== 'undefined') {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }

            } catch (error) {
                console.error("Firebase 初始化失敗:", error);
                // 顯示錯誤訊息給使用者
                allDOMElements.scrambleDisplay.textContent = "錯誤：無法連接到雲端紀錄";
            }
        }

        // --- 資料庫 CRUD (Create, Read, Update, Delete) 函式 ---

        /**
         * (Read) 從 Firestore 讀取成績
         * 使用 onSnapshot 建立一個即時監聽器
         * 每當雲端資料變更時，這個函式會自動觸發並更新 UI
         */
        function loadTimesFromFirestore() {
            if (!solvesCollectionRef) return;

            const q = query(solvesCollectionRef); // 不使用 orderBy 以避免索引錯誤

            onSnapshot(q, (snapshot) => {
                let loadedSolves = [];
                snapshot.forEach(doc => {
                    loadedSolves.push({
                        id: doc.id, // 儲存文件的 ID，以便後續更新或刪除
                        ...doc.data()
                    });
                });

                // 在記憶體中排序 (依時間戳，最新的在最前面)
                times = loadedSolves.sort((a, b) => b.timestamp - a.timestamp);
                
                // 更新所有顯示
                updateAllDisplays();
                console.log("已從 Firestore 同步成績");
            });
        }

        /**
         * (Create) 新增一筆成績到 Firestore
         */
        async function addSolveToDB(solveData) {
            if (!solvesCollectionRef) return;
            try {
                await addDoc(solvesCollectionRef, solveData);
            } catch (error) {
                console.error("新增成績失敗:", error);
            }
        }

        /**
         * (Update) 更新 Firestore 中的一筆成績 (例如 +2 或 DNF)
         */
        async function updateSolveInDB(docId, updateData) {
            if (!solvesCollectionRef) return;
            try {
                const docRef = doc(db, solvesCollectionRef.path, docId);
                await updateDoc(docRef, updateData);
            } catch (error) {
                console.error("更新成績失敗:", error);
            }
        }

        /**
         * (Delete) 從 Firestore 刪除一筆成績
         */
        async function deleteSolveFromDB(docId) {
            if (!solvesCollectionRef) return;
            try {
                const docRef = doc(db, solvesCollectionRef.path, docId);
                await deleteDoc(docRef);
            } catch (error) {
                console.error("刪除成績失敗:", error);
            }
        }

        /**
         * (Delete All) 刪除所有成績
         */
        async function clearAllSolvesFromDB() {
            if (!solvesCollectionRef) return;
            try {
                // 取得所有文件
                const querySnapshot = await getDocs(query(solvesCollectionRef));
                
                // 建立一個批次寫入
                const batch = writeBatch(db);
                querySnapshot.forEach(doc => {
                    batch.delete(doc.ref); // 將刪除操作加入批次
                });
                
                // 執行批次刪除
                await batch.commit();
            } catch (error) {
                console.error("清空成績失敗:", error);
            }
        }

        // --- 原有的函式 (已修改為使用 Firestore) ---

        function startTimer() {
            // ... (原版函式，無需修改) ...
            clearInterval(inspectionInterval);
            timerStartTime = Date.now();
            timerInterval = setInterval(updateTimerDisplay, 10);
            state = 'timing';
            allDOMElements.timerDisplay.className = 'timer-display ' + settings.font;
            document.body.classList.remove('timer-ready', 'timer-inspecting');
        }

        async function stopTimer() {
            // ... (原版函式，僅修改儲存邏輯) ...
            clearInterval(timerInterval);
            timerEndTime = Date.now();
            state = 'initial';
            const solveTime = timerEndTime - timerStartTime;

            // *** 修改點 ***
            // 建立一個 solve 物件，包含時間戳
            const solve = {
                time: solveTime,
                penalty: null,
                scramble: allDOMElements.scrambleDisplay.textContent,
                puzzle: settings.puzzle,
                timestamp: Date.now() // 使用客戶端時間戳
            };

            // 將 'solve' 物件新增到 Firestore
            // 原: times.unshift(solve); saveTimes();
            await addSolveToDB(solve);

            // *** 注意！ ***
            // 我們不再需要手動呼叫 updateAllDisplays()
            // onSnapshot 監聽器會偵測到
            // addSolveToDB 造成的資料庫變動，
            // 並自動觸發 UI 更新！

            // 立即更新主計時器顯示
            allDOMElements.timerDisplay.textContent = formatTime(solveTime);
            // 產生新的打亂
            generateScramble();
        }

        function populateHistoryModal() {
            // ... (原版函式，僅修改刪除按鈕的邏輯) ...
            const { historyList } = allDOMElements;
            historyList.innerHTML = '';
            if (times.length === 0) {
                historyList.innerHTML = '<li class="italic text-gray-400">尚無紀錄</li>';
                return;
            }
            times.forEach((item, index) => {
                const li = document.createElement('li');
                li.className = 'flex items-center justify-between p-2 rounded-lg hover:bg-gray-700 history-item-grid';
                const timeStr = formatRecordTime(item);
                li.innerHTML = `
                    <span class="text-sm text-gray-400">${index + 1}.</span>
                    <span class="font-mono ${item.penalty === 'DNF' ? 'line-through' : ''}">${timeStr}</span>
                    <button class="text-red-400 hover:text-red-600 font-bold" data-index="${index}">刪除</button>
                `;
                
                // *** 修改點：刪除按鈕 ***
                const deleteBtn = li.querySelector('button');
                deleteBtn.addEventListener('click', () => {
                    const solveIdToDelete = item.id; // 使用 Firestore 文件的 ID
                    
                    // 顯示確認視窗
                    showConfirmModal("確定要刪除這筆成績嗎？", async () => {
                        // 原: times.splice(index, 1); saveTimes(); updateAllDisplays();
                        
                        // 新: 呼叫 Firestore 刪除函式
                        await deleteSolveFromDB(solveIdToDelete);
                        
                        // 同樣，onSnapshot 會自動處理 UI 更新
                    });
                });
                historyList.appendChild(li);
            });
        }

        // --- 其餘所有函式 (大多與原版相同) ---
        // (包含 startInspection, handlePressStart, handlePressEnd, updateTimerDisplay, 
        //  formatTime, formatRecordTime, calculateAo, calculateAndDisplayAverages, 
        //  generateScramble, applySettings, saveSettings, loadSettings, showConfirmModal 等)

        // ... (省略所有未修改的函式，它們與原檔案 `破題 - 副本.txt` 相同) ...
        
        // [startInspection, handlePressStart, handlePressEnd, updateTimerDisplay,
        //  formatTime, formatRecordTime, calculateAo, calculateAndDisplayAverages,
        //  generateScramble, applySettings, saveSettings, loadSettings, showConfirmModal
        //  ... 等函式邏輯不變，直接複製貼上]

        function updateAllDisplays() {
            if (times.length > 0) {
                const lastSolve = times[0];
                allDOMElements.timerDisplay.textContent = formatRecordTime(lastSolve);
            } else {
                allDOMElements.timerDisplay.textContent = "0.00";
            }
            calculateAndDisplayAverages();
            populateHistoryModal();
        }

        function loadSettings() {
            const savedSettings = localStorage.getItem('cubeTimerSettingsV2');
            const defaultSettings = {
                theme: 'theme-black',
                puzzle: '3x3',
                font: 'font-roboto-mono',
                inputType: 'timer'
            };
            settings = savedSettings ? { ...defaultSettings, ...JSON.parse(savedSettings) } : defaultSettings;
            applySettings();
        }

        function saveSettings() {
            localStorage.setItem('cubeTimerSettingsV2', JSON.stringify(settings));
        }

        function applySettings() {
            document.body.className = settings.theme;
            allDOMElements.timerDisplay.className = 'timer-display ' + settings.font;
            allDOMElements.themeSelect.value = settings.theme;
            allDOMElements.puzzleSelect.value = settings.puzzle;
            allDOMElements.fontSelect.value = settings.font;
            allDOMElements.inputTypeSelect.value = settings.inputType;

            const isTimerInput = settings.inputType === 'timer';
            allDOMElements.touchInputArea.style.display = isTimerInput ? 'block' : 'none';
            allDOMElements.manualInputArea.style.display = isTimerInput ? 'none' : 'block';

            generateScramble();
            updateAllDisplays(); // 確保切換方塊時統計資料也更新
        }
        
        function showConfirmModal(message, callback) {
            allDOMElements.confirmMessage.textContent = message;
            confirmCallback = callback;
            allDOMElements.confirmModal.classList.remove('hidden');
        }

        function formatTime(ms) {
            if (ms < 0) ms = 0;
            const seconds = Math.floor(ms / 1000);
            const hundredths = Math.floor((ms % 1000) / 10);
            return `${seconds}.${hundredths.toString().padStart(2, '0')}`;
        }

        function formatRecordTime(solve) {
            if (solve.penalty === "DNF") return "DNF";
            let timeStr = formatTime(solve.time);
            if (solve.penalty === "+2") timeStr += "+";
            return timeStr;
        }

        function calculateAo(count) {
            if (times.length < count) return null;
            const relevantTimes = times.slice(0, count).map(s => s.penalty === "DNF" ? Infinity : s.time);
            if (relevantTimes.filter(t => t === Infinity).length > 1) return "DNF";
            
            const sortedTimes = [...relevantTimes].sort((a, b) => a - b);
            sortedTimes.pop(); // remove slowest
            sortedTimes.shift(); // remove fastest
            
            const sum = sortedTimes.reduce((acc, t) => acc + t, 0);
            return sum / (count - 2);
        }

        function calculateAndDisplayAverages() {
            const { bestSolveDisplay, ao5Display, ao12Display, meanDisplay } = allDOMElements;
            
            if (times.length === 0) {
                bestSolveDisplay.textContent = '-.--';
                ao5Display.textContent = '-.--';
                ao12Display.textContent = '-.--';
                meanDisplay.textContent = '-.--';
                return;
            }

            const validTimes = times.filter(s => s.penalty !== 'DNF').map(s => s.time);
            const bestTime = validTimes.length > 0 ? Math.min(...validTimes) : null;
            bestSolveDisplay.textContent = bestTime !== null ? formatTime(bestTime) : 'DNF';

            const ao5 = calculateAo(5);
            ao5Display.textContent = ao5 === null ? '-.--' : (ao5 === "DNF" ? "DNF" : formatTime(ao5));
            
            const ao12 = calculateAo(12);
            ao12Display.textContent = ao12 === null ? '-.--' : (ao12 === "DNF" ? "DNF" : formatTime(ao12));
            
            const mean = validTimes.length > 0 ? (validTimes.reduce((a, b) => a + b, 0) / validTimes.length) : null;
            meanDisplay.textContent = mean !== null ? formatTime(mean) : 'DNF';
        }

        function generateScramble() {
            const { scrambleDisplay } = allDOMElements;
            const L = 10;
            const moves = {
                "3x3": ["R", "L", "U", "D", "F", "B"],
                "2x2": ["R", "U", "F"],
                "4x4": ["R", "L", "U", "D", "F", "B", "Rw", "Lw", "Uw", "Dw", "Fw", "Bw"],
                "5x5": ["R", "L", "U", "D", "F", "B", "Rw", "Lw", "Uw", "Dw", "Fw", "Bw"],
                "6x6": ["R", "L", "U", "D", "F", "B", "Rw", "Lw", "Uw", "Dw", "Fw", "Bw", "3Rw", "3Lw", "3Uw", "3Dw", "3Fw", "3Bw"],
                "7x7": ["R", "L", "U", "D", "F", "B", "Rw", "Lw", "Uw", "Dw", "Fw", "Bw", "3Rw", "3Lw", "3Uw", "3Dw", "3Fw", "3Bw"],
                "pyra": ["R", "L", "U", "B", "r", "l", "u", "b"],
                "mega": ["R++", "R--", "D++", "D--", "U", "U'"],
                "skewb": ["R", "L", "U", "B"],
                // 'sq1': 缺少 SQ1 打亂
            };
            const suffixes = ["", "'", "2"];
            const lengths = { "3x3": 20, "2x2": 9, "4x4": 40, "5x5": 60, "6x6": 80, "7x7": 100, "pyra": 11, "mega": 77, "skewb": 9 };
            
            let scramble = "";
            let puzzleType = settings.puzzle;
            
            if (moves[puzzleType]) {
                const pMoves = moves[puzzleType];
                const pLength = lengths[puzzleType];
                let lastMove = -1;
                for (let i = 0; i < pLength; i++) {
                    let move;
                    do {
                        move = Math.floor(Math.random() * pMoves.length);
                    } while (move === lastMove || (puzzleType.match(/^[4-7]x[4-7]$/) && move % 6 === lastMove % 6));
                    
                    scramble += pMoves[move];
                    if (puzzleType !== 'mega') {
                        scramble += suffixes[Math.floor(Math.random() * suffixes.length)];
                    }
                    scramble += " ";
                    lastMove = move;
                }
            } else if (puzzleType.match(/^[2-7]x[2-7]$/)) { // 處理 '3x3' 以外的 NxN
                const n = parseInt(puzzleType[0]);
                const standardMoves = ["R", "L", "U", "D", "F", "B"];
                const wideMoves = ["Rw", "Lw", "Uw", "Dw", "Fw", "Bw"];
                const innerMoves = n > 5 ? ["3Rw", "3Lw", "3Uw", "3Dw", "3Fw", "3Bw"] : [];
                const allMoves = [...standardMoves, ...wideMoves, ...innerMoves];
                const pLength = lengths[puzzleType] || 20 * (n - 2);
                let lastMove = -1;
                for (let i = 0; i < pLength; i++) {
                    let move;
                    do {
                        move = Math.floor(Math.random() * allMoves.length);
                    } while (move === lastMove);
                    scramble += allMoves[move] + suffixes[Math.floor(Math.random() * suffixes.length)] + " ";
                    lastMove = move;
                }
            } else if (puzzleType === 'sq1') {
                scramble = "注意：此版本尚未支援 Square-1 打亂。";
            }

            scrambleDisplay.textContent = scramble.trim();
        }

        function startInspection() {
            if (state !== 'initial') return;
            state = 'inspecting';
            inspectionStartTime = Date.now();
            allDOMElements.timerDisplay.textContent = "0.00";
            allDOMElements.timerDisplay.className = 'timer-display ' + settings.font + ' timer-inspecting';
            
            // --- MODIFIED: Faster inspection time ---
            pressTimeout = setTimeout(() => {
                if (state === 'inspecting') {
                    state = 'ready';
                    allDOMElements.timerDisplay.className = 'timer-display ' + settings.font + ' timer-ready';
                }
            }, 500); // 0.5 秒後變綠
        }

        function handlePressStart(e) {
            e.preventDefault();
            if (settings.inputType !== 'timer') return;
            
            if (state === 'initial') {
                startInspection();
            } else if (state === 'timing') {
                stopTimer();
            }
        }

        function handlePressEnd(e) {
            e.preventDefault();
            if (settings.inputType !== 'timer') return;

            clearTimeout(pressTimeout);
            if (state === 'ready') {
                startTimer();
            } else if (state === 'inspecting') {
                state = 'initial';
                allDOMElements.timerDisplay.className = 'timer-display ' + settings.font;
            }
        }

        // --- 程式進入點 (DOM PContentLoaded) ---
        document.addEventListener('DOMContentLoaded', () => {
            // 綁定所有 DOM 元素 (這部分程式碼較長，保持不變)
            const UIElements = {
                timerDisplay: 'timer-display',
                scrambleDisplay: 'scramble-display',
                statsPanel: 'stats-panel',
                bestSolveDisplay: 'best-solve',
                ao5Display: 'ao5-solve',
                ao12Display: 'ao12-solve',
                meanDisplay: 'mean-solve',
                loginModal: 'login-modal',
                loginForm: 'login-form',
                loginUsername: 'login-username',
                loginPassword: 'login-password',
                loginError: 'login-error',
                mainContent: 'main-content',
                settingsBtn: 'settings-btn',
                historyBtn: 'history-btn',
                otherBtnComputer: 'other-btn-computer',
                otherBtnTouch: 'other-btn-touch',
                settingsModal: 'settings-modal',
                closeSettingsBtn: 'close-settings-btn',
                themeSelect: 'theme-select',
                puzzleSelect: 'puzzle-select',
                fontSelect: 'font-select',
                inputTypeSelect: 'input-type-select',
                historyModal: 'history-modal',
                closeHistoryBtn: 'close-history-btn',
                historyList: 'history-list',
                historyClearAllBtn: 'history-clear-all',
                otherModal: 'other-modal',
                closeOtherBtn: 'close-other-btn',
                lastSolveDisplay: 'last-solve-display',
                plus2Btn: 'plus2-btn',
                dnfBtn: 'dnf-btn',
                confirmModal: 'confirm-modal',
                confirmMessage: 'confirm-message',
                confirmOkBtn: 'confirm-ok-btn',
                confirmCancelBtn: 'confirm-cancel-btn',
                touchInputArea: 'touch-input-area',
                manualInputArea: 'manual-input-area',
                manualTimeInput: 'manual-time-input',
                manualAddBtn: 'manual-add-btn'
            };
            for (const key in UIElements) {
                allDOMElements[key] = document.getElementById(UIElements[key]);
            }

            // --- 登入邏輯 (保持不變) ---
            const hardcodedUsers = { "user": "123", "gemini": "abc" };
            allDOMElements.loginForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const username = allDOMElements.loginUsername.value;
                const password = allDOMElements.loginPassword.value;
                if (hardcodedUsers[username] && hardcodedUsers[username] === password) {
                    allDOMElements.loginModal.classList.add('hidden');
                    allDOMElements.mainContent.classList.remove('hidden');
                    
                    // *** 修改點 ***
                    // 登入成功後，才初始化 Firebase
                    initFirebase(); 
                } else {
                    allDOMElements.loginError.classList.remove('hidden');
                }
            });

            // --- 事件監聽器 (修改為使用 Firestore 函式) ---
            
            // 觸控與鍵盤事件 (保持不變)
            const touchArea = allDOMElements.touchInputArea;
            touchArea.addEventListener('touchstart', handlePressStart);
            touchArea.addEventListener('touchend', handlePressEnd);
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' && (state === 'initial' || state === 'timing') && settings.inputType === 'timer') {
                    if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'SELECT') {
                        e.preventDefault();
                        if (state === 'initial') handlePressStart(e);
                    }
                }
            });
            document.addEventListener('keyup', (e) => {
                if (e.code === 'Space' && (state === 'inspecting' || state === 'ready') && settings.inputType === 'timer') {
                    if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'SELECT') {
                        e.preventDefault();
                        handlePressEnd(e);
                    }
                }
            });

            // 設定
            allDOMElements.settingsBtn.addEventListener('click', () => allDOMElements.settingsModal.classList.remove('hidden'));
            allDOMElements.closeSettingsBtn.addEventListener('click', () => allDOMElements.settingsModal.classList.add('hidden'));
            [allDOMElements.themeSelect, allDOMElements.puzzleSelect, allDOMElements.fontSelect, allDOMElements.inputTypeSelect].forEach(select => {
                select.addEventListener('change', () => {
                    settings[select.id.split('-')[0]] = select.value;
                    applySettings();
                    saveSettings();
                });
            });

            // 歷史紀錄
            allDOMElements.historyBtn.addEventListener('click', () => allDOMElements.historyModal.classList.remove('hidden'));
            allDOMElements.closeHistoryBtn.addEventListener('click', () => allDOMElements.historyModal.classList.add('hidden'));
            
            // *** 修改點：清空按鈕 ***
            allDOMElements.historyClearAllBtn.addEventListener('click', () => {
                showConfirmModal("確定要刪除 *所有* 成績嗎？此操作無法復原！", async () => {
                    // 原: times = []; saveTimes(); updateAllDisplays();
                    await clearAllSolvesFromDB();
                    allDOMElements.historyModal.classList.add('hidden');
                });
            });

            // 其他 (+2 / DNF)
            [allDOMElements.otherBtnComputer, allDOMElements.otherBtnTouch].forEach(btn => btn.addEventListener('click', () => {
                const { lastSolveDisplay, plus2Btn, dnfBtn } = allDOMElements;
                if (times.length === 0) {
                    lastSolveDisplay.textContent = '-.--';
                    plus2Btn.disabled = true;
                    dnfBtn.disabled = true;
                } else {
                    lastSolveDisplay.textContent = formatRecordTime(times[0]);
                    const hasPenalty = times[0].penalty !== null;
                    plus2Btn.disabled = hasPenalty;
                    dnfBtn.disabled = hasPenalty;
                }
                allDOMElements.otherModal.classList.remove('hidden');
            }));
            allDOMElements.closeOtherBtn.addEventListener('click', () => allDOMElements.otherModal.classList.add('hidden'));

            // *** 修改點：+2 按鈕 ***
            allDOMElements.plus2Btn.addEventListener('click', async () => {
                if (times.length > 0 && times[0].penalty === null) {
                    const solveToUpdate = times[0];
                    // 原: times[0].penalty = "+2"; times[0].time += 2000; saveTimes(); updateAllDisplays();
                    await updateSolveInDB(solveToUpdate.id, {
                        penalty: "+2",
                        time: solveToUpdate.time + 2000
                    });
                    allDOMElements.otherModal.classList.add('hidden');
                }
            });

            // *** 修改點：DNF 按鈕 ***
            allDOMElements.dnfBtn.addEventListener('click', async () => {
                if (times.length > 0 && times[0].penalty === null) {
                    // 原: times[0].penalty = "DNF"; saveTimes(); updateAllDisplays();
                    await updateSolveInDB(times[0].id, { penalty: "DNF" });
                    allDOMElements.otherModal.classList.add('hidden');
                }
            });

            // 確認視窗 (保持不變)
            allDOMElements.confirmCancelBtn.addEventListener('click', () => {
                confirmCallback = null;
                allDOMElements.confirmModal.classList.add('hidden');
            });
            allDOMElements.confirmOkBtn.addEventListener('click', () => {
                if (confirmCallback) confirmCallback();
                confirmCallback = null;
                allDOMElements.confirmModal.classList.add('hidden');
            });

            // 手動輸入
            allDOMElements.manualAddBtn.addEventListener('click', async () => {
                const timeStr = allDOMElements.manualTimeInput.value;
                const timeInMs = parseFloat(timeStr) * 1000;
                if (!isNaN(timeInMs) && timeInMs > 0) {
                    const solve = {
                        time: timeInMs,
                        penalty: null,
                        scramble: "手動輸入",
                        puzzle: settings.puzzle,
                        timestamp: Date.now()
                    };
                    // *** 修改點 ***
                    // 原: times.unshift(solve); saveTimes(); updateAllDisplays();
                    await addSolveToDB(solve);
                    
                    allDOMElements.manualTimeInput.value = '';
                } else {
                    alert("請輸入有效的秒數 (例如 12.34)");
                }
            });

            // 初始載入設定 (注意：Firebase 相關的載入會在登入後才執行)
            loadSettings();
        });
    </script>
</head>

<!-- HTML 結構 (與原版 `破題 - 副本.txt` 完全相同) -->
<body class="theme-black">

    <!-- 登入畫面 -->
    <div id="login-modal" class="fixed inset-0 z-50 flex items-center justify-center bg-gray-900 bg-opacity-75">
        <div class="bg-gray-800 p-8 rounded-lg shadow-xl w-full max-w-sm">
            <h2 class="text-2xl font-bold text-center mb-6">登入計時器</h2>
            <form id="login-form">
                <div class="mb-4">
                    <label for="login-username" class="block text-sm font-medium text-gray-300 mb-2">帳號</label>
                    <input type="text" id="login-username" class="w-full px-3 py-2 bg-gray-700 text-white rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" value="user">
                </div>
                <div class="mb-6">
                    <label for="login-password" class="block text-sm font-medium text-gray-300 mb-2">密碼</label>
                    <input type="password" id="login-password" class="w-full px-3 py-2 bg-gray-700 text-white rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" value="123">
                </div>
                <p id="login-error" class="text-red-400 text-sm text-center mb-4 hidden">帳號或密碼錯誤。</p>
                <button type="submit" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition-colors">
                    登入
                </button>
            </form>
        </div>
    </div>

    <!-- 主內容 (預設隱藏) -->
    <div id="main-content" class="hidden h-screen flex flex-col">
        <!-- 頂部：打亂 / 電腦版按鈕 -->
        <header class="flex-shrink-0 p-4 md:p-6">
            <div class="max-w-4xl mx-auto flex justify-between items-center">
                <div id="scramble-display" class="text-lg md:text-xl text-center font-medium flex-1 mr-4">
                    正在載入打亂...
                </div>
                <div class="hidden md:flex space-x-2">
                    <button id="settings-btn" class="px-3 py-2 bg-gray-700 bg-opacity-50 rounded-md hover:bg-opacity-75 transition-colors">設定</button>
                    <button id="history-btn" class="px-3 py-2 bg-gray-700 bg-opacity-50 rounded-md hover:bg-opacity-75 transition-colors">紀錄</button>
                    <button id="other-btn-computer" class="px-3 py-2 bg-gray-700 bg-opacity-50 rounded-md hover:bg-opacity-75 transition-colors">其他</button>
                </div>
            </div>
        </header>

        <!-- 中間：計時器 / 統計 -->
        <main id="touch-input-area" class="flex-grow flex flex-col items-center justify-center select-none p-4">
            <h1 id="timer-display" class="font-roboto-mono text-8xl md:text-9xl lg:text-[10rem] font-bold" style="font-size: clamp(4.5rem, 20vw, 10rem);">
                0.00
            </h1>
        </main>
        
        <!-- 手動輸入區域 (預設隱藏) -->
        <div id="manual-input-area" class="hidden flex-grow flex-col items-center justify-center p-4">
            <div class="flex items-center space-x-2">
                <input id="manual-time-input" type="number" step="0.01" class="px-4 py-3 text-2xl bg-gray-700 text-white rounded-md w-48 text-right" placeholder="12.34">
                <button id="manual-add-btn" class="px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded-md transition-colors text-lg">
                    新增
                </button>
            </div>
        </div>

        <!-- 底部：統計 / 手機版按鈕 -->
        <footer class="flex-shrink-0 p-4 md:p-6">
            <div id="stats-panel" class="grid grid-cols-2 sm:grid-cols-4 gap-2 max-w-2xl mx-auto font-mono text-center">
                <div class="bg-gray-700 bg-opacity-30 p-2 rounded-md">
                    <div class="text-sm text-gray-400">Best</div>
                    <div id="best-solve" class="text-lg font-medium">-.--</div>
                </div>
                <div class="bg-gray-700 bg-opacity-30 p-2 rounded-md">
                    <div class="text-sm text-gray-400">Ao5</div>
                    <div id="ao5-solve" class="text-lg font-medium">-.--</div>
                </div>
                <div class="bg-gray-700 bg-opacity-30 p-2 rounded-md">
                    <div class="text-sm text-gray-400">Ao12</div>
                    <div id="ao12-solve" class="text-lg font-medium">-.--</div>
                </div>
                <div class="bg-gray-700 bg-opacity-30 p-2 rounded-md">
                    <div class="text-sm text-gray-400">Mean</div>
                    <div id="mean-solve" class="text-lg font-medium">-.--</div>
                </div>
            </div>
            <div class="md:hidden flex justify-around items-center mt-4 p-2 bg-gray-800 bg-opacity-50 rounded-lg">
                <button id="settings-btn-touch" class="p-3 text-gray-300">設定</button>
                <button id="history-btn-touch" class="p-3 text-gray-300">紀錄</button>
                <button id="other-btn-touch" class="p-3 text-gray-300">其他</button>
            </div>
        </footer>
    </div>

    <!-- 彈出視窗：設定 -->
    <div id="settings-modal" class="fixed inset-0 z-30 flex items-center justify-center bg-gray-900 bg-opacity-75 hidden">
        <div class="bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-md">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-2xl font-bold">設定</h2>
                <button id="close-settings-btn" class="text-2xl text-gray-400 hover:text-white">&times;</button>
            </div>
            <div class="space-y-4">
                <div>
                    <label for="theme-select" class="block text-sm font-medium text-gray-300 mb-2">主題</label>
                    <select id="theme-select" class="w-full px-3 py-2 bg-gray-700 text-white rounded-md focus:outline-none">
                        <option value="theme-black">黑色 (預設)</option>
                        <option value="theme-white">白色</option>
                        <option value="theme-blue">藍色</option>
                        <option value="theme-mint">薄荷</option>
                        <option value="theme-synthwave">Synthwave</option>
                        <option value="theme-solarized">Solarized</option>
                    </select>
                </div>
                <div>
                    <label for="puzzle-select" class="block text-sm font-medium text-gray-300 mb-2">WCA 項目</label>
                    <select id="puzzle-select" class="w-full px-3 py-2 bg-gray-700 text-white rounded-md focus:outline-none">
                        <option value="3x3">3x3x3</option>
                        <option value="2x2">2x2x2</option>
                        <option value="4x4">4x4x4</option>
                        <option value="5x5">5x5x5</option>
                        <option value="6x6">6x6x6</option>
                        <option value="7x7">7x7x7</option>
                        <option value="pyra">Pyraminx</option>
                        <option value="mega">Megaminx</option>
                        <option value="skewb">Skewb</option>
                        <option value="sq1">Square-1</option>
                    </select>
                </div>
                <div>
                    <label for="font-select" class="block text-sm font-medium text-gray-300 mb-2">計時器字體</label>
                    <select id="font-select" class="w-full px-3 py-2 bg-gray-700 text-white rounded-md focus:outline-none">
                        <option value="font-roboto-mono">Roboto Mono (預設)</option>
                        <option value="font-noto-sans">Noto Sans TC</option>
                    </select>
                </div>
                <div>
                    <label for="input-type-select" class="block text-sm font-medium text-gray-300 mb-2">輸入模式</label>
                    <select id="input-type-select" class="w-full px-3 py-2 bg-gray-700 text-white rounded-md focus:outline-none">
                        <option value="timer">計時器 (空白鍵/觸控)</option>
                        <option value="manual">手動輸入</option>
                    </select>
                </div>
            </div>
        </div>
    </div>

    <!-- 彈出視窗：紀錄 -->
    <div id="history-modal" class="fixed inset-0 z-30 flex items-center justify-center bg-gray-900 bg-opacity-75 hidden">
        <div class="bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-md h-[70vh] flex flex-col">
            <div class="flex justify-between items-center mb-6 flex-shrink-0">
                <h2 class="text-2xl font-bold">成績紀錄</h2>
                <button id="close-history-btn" class="text-2xl text-gray-400 hover:text-white">&times;</button>
            </div>
            <ul id="history-list" class="flex-grow overflow-y-auto space-y-1 modal-content pr-2">
                <!-- 紀錄項目會由 JS 動態填入 -->
            </ul>
            <button id="history-clear-all" class="mt-4 w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md transition-colors">
                清空所有紀錄
            </button>
        </div>
    </div>

    <!-- 彈出視窗：其他 (+2 / DNF) -->
    <div id="other-modal" class="fixed inset-0 z-30 flex items-center justify-center bg-gray-900 bg-opacity-75 hidden">
        <div class="bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-sm">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-2xl font-bold">判罰</h2>
                <button id="close-other-btn" class="text-2xl text-gray-400 hover:text-white">&times;</button>
            </div>
            <div class="space-y-4">
                <div class="text-center">
                    <span class="text-sm text-gray-400">上次成績</span>
                    <p id="last-solve-display" class="text-3xl font-mono">-.--</p>
                </div>
                <button id="plus2-btn" class="w-full bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-3 px-4 rounded-md transition-colors text-lg disabled:opacity-50 disabled:cursor-not-allowed">
                    +2
                </button>
                <button id="dnf-btn" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-md transition-colors text-lg disabled:opacity-50 disabled:cursor-not-allowed">
                    DNF
                </button>
            </div>
        </div>
    </div>

    <!-- 彈出視窗：確認 -->
    <div id="confirm-modal" class="fixed inset-0 z-40 flex items-center justify-center bg-gray-900 bg-opacity-80 hidden">
        <div class="bg-gray-700 p-6 rounded-lg shadow-xl w-full max-w-xs">
            <p id="confirm-message" class="text-center mb-6">確定要執行此操作嗎？</p>
            <div class="flex justify-around">
                <button id="confirm-cancel-btn" class="px-6 py-2 bg-gray-500 hover:bg-gray-600 rounded-md transition-colors">取消</button>
                <button id="confirm-ok-btn" class="px-6 py-2 bg-red-600 hover:bg-red-700 rounded-md transition-colors">確定</button>
            </div>
        </div>
    </div>

</body>
</html>
